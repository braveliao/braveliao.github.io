<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Geepi&#39;s blog</title>
  
  
  <link href="https://braveliao.github.io/atom.xml" rel="self"/>
  
  <link href="https://braveliao.github.io/"/>
  <updated>2025-02-18T11:37:30.804Z</updated>
  <id>https://braveliao.github.io/</id>
  
  <author>
    <name>Geepi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://braveliao.github.io/2025/02/18/tool/p6-ti-sheng/posts/undefined/"/>
    <id>https://braveliao.github.io/2025/02/18/tool/p6-ti-sheng/posts/undefined/</id>
    <published>2025-02-18T11:37:30.804Z</published>
    <updated>2025-02-18T11:37:30.804Z</updated>
    
    <content type="html"><![CDATA[<p>P6提升</p><ul><li><p>知识图谱</p><ul><li>源码：Spring Boot启动源码分析、Netty源码分析</li><li>Java基础能力提升：jvm、多线程</li><li>设计模式：</li></ul></li><li><p>绩效目标</p><ul><li>Spring核心原理：<ul><li>熟悉、了解Spring源码与核心原理；</li><li>Spring时序图绘制：<ul><li>手绘SpringIOC运行时序图</li><li>SpringDI运行时许图、SpringAOP运行时序图</li><li>SpringAOP运行时序图</li><li>SpringMVC运行时序图</li></ul></li><li>手写实战：用300行代码手写提炼Spring的核心原理；</li></ul></li><li>设计模式：<ul><li>熟悉、了解，以及应用常用设计模式，博阿酷哦：创建型模式、结构型模式、行为模式</li><li>个设计模式对比总结以及应用场景分析</li></ul></li><li>高性能NIO框架：<ul><li>Netty初体验:Netty与NIO前世今生；基于Netty手写Tomcat，基于Netty重构RPC框架；</li><li>Netty实战篇:基于Netty手写消息推送系统，单机百万链接与应用级性能调优；</li></ul></li></ul></li><li><p>具体实施</p><ul><li>记录：比较记录到csdn，新建一个目录：P6提升；</li><li>目标：保证每周一篇更新吧；</li><li>学习方式：<ul><li>采用B站的视频学习；</li><li>书籍学习；</li><li>时间安排：固定周天上午4h；爬山的时候带耳机，听B站视频</li><li>学习场所：工商大学自习室；</li><li>需要购买一个蓝牙运动耳机；</li></ul></li></ul></li><li><p>名录：</p><ul><li>B站视频：马士兵源码“三部曲”：Spring源码-MyBatis源码-SpringBoot源码，【2022最强版】一举通关！（<a href="https://www.bilibili.com/video/BV1Z44y1b775/?buvid=XUC840DC28920F2EA8E3AFDAF154210CFF10A&from_spmid=playlist.playlist-detail.0.0&is_story_h5=false&mid=4+D4RgLHSLuL306fKNSviA==&p=1&plat_id=116&share_from=ugc&share_medium=android&share_plat=android&share_session_id=fabe24c7-2f40-47b3-a229-360657eab331&share_source=WEIXIN&share_tag=s_i&spmid=united.player-video-detail.0.0&timestamp=1737863196&unique_k=NwynEat&up_id=2081613871%EF%BC%89">https://www.bilibili.com/video/BV1Z44y1b775/?buvid=XUC840DC28920F2EA8E3AFDAF154210CFF10A&amp;from_spmid=playlist.playlist-detail.0.0&amp;is_story_h5=false&amp;mid=4%2BD4RgLHSLuL306fKNSviA%3D%3D&amp;p=1&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=fabe24c7-2f40-47b3-a229-360657eab331&amp;share_source=WEIXIN&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1737863196&amp;unique_k=NwynEat&amp;up_id=2081613871）</a></li><li>书籍：Netty 权威指南（第2版）、Java核心技术 卷I 基础知识</li></ul></li><li><p>实施细则：</p><ol><li>SpringBoot的学习：</li></ol><ul><li>Spring系列之IOC的原理及手动实现 <a href="https://juejin.cn/post/6844903736456773646?searchId=20250205140648F396238176583D8137E7">https://juejin.cn/post/6844903736456773646?searchId=20250205140648F396238176583D8137E7</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;P6提升&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;知识图谱&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源码：Spring Boot启动源码分析、Netty源码分析&lt;/li&gt;
&lt;li&gt;Java基础能力提升：jvm、多线程&lt;/li&gt;
&lt;li&gt;设计模式：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring Boot学习-手写ioc并理解核心原理</title>
    <link href="https://braveliao.github.io/2025/02/09/springboot-xue-xi/spring-xi-lie-zhi-ioc-de-yuan-li-ji-shou-dong-shi-xian/posts/undefined/"/>
    <id>https://braveliao.github.io/2025/02/09/springboot-xue-xi/spring-xi-lie-zhi-ioc-de-yuan-li-ji-shou-dong-shi-xian/posts/undefined/</id>
    <published>2025-02-09T06:51:22.000Z</published>
    <updated>2025-02-18T11:37:30.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="核心理解："><a href="#核心理解：" class="headerlink" title="核心理解："></a>核心理解：</h1><ol><li>ioc的名字理解：全称为Inversion of Controller</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在传统的编程模型中，对象的创建和依赖关系是由程序本身显式控制的。也就是说，程序员需要手动创建对象并将它们注入到其他对象中。这种方式被称为 控制（Control），程序员有完全的控制权来管理对象的生命周期和依赖关系。</span><br><span class="line"></span><br><span class="line">而 控制反转（IoC） 则是将这些控制权从程序中反转到框架或容器中。换句话说，IoC 允许框架（如 Spring）负责对象的创建和管理，而程序员则无需手动控制对象的生命周期和依赖关系。对象的创建和注入是由 IoC 容器来管理的。</span><br></pre></td></tr></table></figure><ol start="2"><li>核心功能：对Bean进行管理，包括创建、使用、销毁等；</li><li>ioc最核心的实现方式：依赖注入（DI）;</li></ol><h1 id="核心代码实现："><a href="#核心代码实现：" class="headerlink" title="核心代码实现："></a>核心代码实现：</h1><ol><li>创建一个简单的接口和实现类：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 定义服务接口</span><br><span class="line">public interface GreetingService &#123;</span><br><span class="line">    void greet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现 GreetingService</span><br><span class="line">public class GreetingServiceImpl implements GreetingService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void greet() &#123;</span><br><span class="line">        System.out.println(&quot;Hello, welcome to IoC container!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.创建一个简单的ioc容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">// 简单的 IoC 容器实现</span><br><span class="line">public class SimpleIoCContainer &#123;</span><br><span class="line">    private Map&lt;Class&lt;?&gt;, Object&gt; container = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    // 注册对象到容器</span><br><span class="line">    public void register(Class&lt;?&gt; clazz, Object object) &#123;</span><br><span class="line">        container.put(clazz, object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据类型获取对象</span><br><span class="line">    public &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        return clazz.cast(container.get(clazz));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用ioc容器</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">// 简单的 IoC 容器实现</span><br><span class="line">public class SimpleIoCContainer &#123;</span><br><span class="line">    private Map&lt;Class&lt;?&gt;, Object&gt; container = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    // 注册对象到容器</span><br><span class="line">    public void register(Class&lt;?&gt; clazz, Object object) &#123;</span><br><span class="line">        container.put(clazz, object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据类型获取对象</span><br><span class="line">    public &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        return clazz.cast(container.get(clazz));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;核心理解：&quot;&gt;&lt;a href=&quot;#核心理解：&quot; class=&quot;headerlink&quot; title=&quot;核心理解：&quot;&gt;&lt;/a&gt;核心理解：&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;ioc的名字理解：全称为Inversion of Controller&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;在传统的编程模型中，对象的创建和依赖关系是由程序本身显式控制的。也就是说，程序员需要手动创建对象并将它们注入到其他对象中。这种方式被称为 控制（Control），程序员有完全的控制权来管理对象的生命周期和依赖关系。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;而 控制反转（IoC） 则是将这些控制权从程序中反转到框架或容器中。换句话说，IoC 允许框架（如 Spring）负责对象的创建和管理，而程序员则无需手动控制对象的生命周期和依赖关系。对象的创建和注入是由 IoC 容器来管理的。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Java" scheme="https://braveliao.github.io/categories/Java/"/>
    
    
    <category term="Spring Boot" scheme="https://braveliao.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Arthas</title>
    <link href="https://braveliao.github.io/2025/02/09/arthas/arthas/posts/undefined/"/>
    <id>https://braveliao.github.io/2025/02/09/arthas/arthas/posts/undefined/</id>
    <published>2025-02-09T06:51:22.000Z</published>
    <updated>2025-02-18T11:37:30.804Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><a href="https://github.com/alibaba/arthas/issues/71">Arthas的一些特殊用法文档说明 · Issue #71 · alibaba&#x2F;arthas</a></p></li><li><p><a href="https://github.com/alibaba/arthas/issues/1424">arthas 获取spring被代理的目标对象 · Issue #1424 · alibaba&#x2F;arthas</a></p></li><li><p><a href="https://github.com/alibaba/arthas/issues/537">Arthas实践–jad&#x2F;mc&#x2F;redefine线上热更新一条龙 · Issue #537 · alibaba&#x2F;arthas</a></p></li></ul><h3 id="1-获取当前HttpServletRequest"><a href="#1-获取当前HttpServletRequest" class="headerlink" title="1. 获取当前HttpServletRequest"></a>1. 获取当前HttpServletRequest</h3><ul><li><p>执行某个request方法</p><p>  <code>@org.springframework.web.context.request.RequestContextHolder@currentRequestAttributes().getRequest().xxx</code></p></li><li><p>获取全部的请求头</p><p>  <code>@org.springframework.web.context.request.RequestContextHolder@currentRequestAttributes().getRequest().getHeaderNames()</code></p></li></ul><h3 id="2-获取spring-context-并执行某些操作"><a href="#2-获取spring-context-并执行某些操作" class="headerlink" title="2. 获取spring context 并执行某些操作"></a>2. 获取spring context 并执行某些操作</h3><blockquote><p><strong>前置</strong> 使用tt记录请求，获取到上下文</p><p>tt -t org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter invokeHandlerMethod -n 3</p></blockquote><pre><code>tt -i 1000 -w &#39;target.getApplicationContext().getBean(&quot;jdbcTemplate&quot;)&#39;tt -i 1000 -w &#39;target.getApplicationContext().getBean(&quot;jdbcTemplate&quot;).dataSource.ConnectionPool&#39;tt -i 1000 -w &#39;target.getApplicationContext().getBean(&quot;jdbcTemplate&quot;).getTargetSource().target&#39;tt -i 1000 -w &#39;target.getApplicationContext().getBean(&quot;jdbcTemplate&quot;).getTargetSource().target.cacheMap&#39;tt -i 1000  -w &#39;target.getApplicationContext().getEnvironment().getProperty(&quot;spring.datasource.riskctrl.url&quot;)&#39;</code></pre><h3 id="3-使用ognl"><a href="#3-使用ognl" class="headerlink" title="3. 使用ognl"></a>3. 使用<a href="https://commons.apache.org/dormant/commons-ognl/language-guide.html">ognl</a></h3><ul><li><p>对前置表达式值进行二次计算  #this 表示前置表达式的值 <strong><code>.()</code></strong> 表示自表达式，产生一个单一值</p><p>  <strong><code>listeners.size().(#this &gt; 100? 2\*#this : 20+#this)</code></strong></p></li><li><p>对前置表达式进行二次计算，产生一个数组</p><p>  <strong><code>params[0].&#123;#this == &quot;lei&quot; ?  &quot;yes&quot; : &quot;no&quot;&#125;</code></strong></p></li><li><p>对前置表达式(数组类型)进行二次计算，产生一个新的数组</p><p>  <strong><code>params.&#123;#this instanceof String ?  &quot;yes&quot; : &quot;no&quot;&#125;</code></strong></p></li><li><p>返回数组中第一个匹配的对象</p><p>  <strong><code>params.&#123;^#this instanceof Integer&#125;</code></strong></p></li><li><p>调用static方法 使用  <strong>@class@method(<strong><strong>args</strong></strong>)</strong></p><p>  <strong><code>@org.springframework.web.context.request.RequestContextHolder@currentRequestAttributes()</code></strong></p></li><li><p>获取静态字段 <strong>@class@field</strong></p></li></ul><h3 id="4-一些常用命令"><a href="#4-一些常用命令" class="headerlink" title="4. 一些常用命令"></a>4. 一些常用命令</h3><ul><li><p>获取classloader hash，如果是springBoot项目取 org.springframework.boot.loader.LaunchedURLClassLoader</p><p>  <strong><code>classloader -t</code></strong></p></li><li><p>容器安装 vim</p><p>  <strong><code>apt-get update &amp;&amp; apt-get install -y vim</code></strong></p></li><li><p>Ognl 获取spring context</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 49c2faae 表示classloader hash</span><br><span class="line"># cn.hutool.extra.spring.SpringUtil 表示能获取到spring容器的方法</span><br><span class="line">ognl -c 49c2faae &#x27;#beanName=&quot;eventDataAuthManage&quot;, #bean=@cn.hutool.extra.spring.SpringUtil@getBean(#beanName), @org.springframework.aop.support.AopUtils@getTargetClass(#bean).getName()&#x27;</span><br></pre></td></tr></table></figure></li><li><p>Ognl lambda 表达式</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 使用 =:[] 定义lambda即函数</span><br><span class="line">-- 使用 #getBean() 调用</span><br><span class="line">ognl -c 49c2faae &#x27;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">getBean =:[@cn.hutool.extra.spring.SpringUtil@getBean(#this)],</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">getBean(<span class="string">&quot;syncDataAuthController&quot;</span>).dataCodeList<span class="string">&#x27;</span></span></span><br></pre></td></tr></table></figure></li><li><p>查找方法</p><p>  <strong><code>sm com.xx.class</code></strong></p></li><li><p>修改静态变量的值</p><p>  <strong><code>getstatic com.xyz.HelloWorld s &quot;#s=&#39;abc&#39;&quot;</code></strong></p></li><li><p>修改变量的值</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 1. 使用 tt 记录方法调用</span><br><span class="line">tt -t com.example.UserService getUserById</span><br><span class="line">-- 2. 查看记录</span><br><span class="line">tt -l</span><br><span class="line">-- 3. 修改捕获的对象 target 代表当前被调用方法的对象实例（即 &quot;this&quot; 对象）</span><br><span class="line">tt -i 1000 -w &#x27;target.name=&quot;newName&quot;&#x27;</span><br></pre></td></tr></table></figure></li><li><p>过滤参数类型为class的方法</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 过滤要点就是通过全类名@class拿到class对象，再getName()获取名称</span><br><span class="line">watch com.wangji92.arthas.plugin.demo.controller.StaticTest invokeClass &#x27;&#123;returnObj,throwExp&#125;&#x27;  -n 5  -x 3  </span><br><span class="line">&#x27;params[0].getName().equals(@com.wangji92.arthas.plug.demo.controller.User@class.getName())&#x27; -v</span><br></pre></td></tr></table></figure></li><li><p>查找response404的堆栈</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack -E javax.servlet.http.HttpServletResponse sendError|setStatus params[0]==404</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-特殊命令"><a href="#5-特殊命令" class="headerlink" title="5. 特殊命令"></a>5. 特殊命令</h3><ul><li><p>Trace 命令多个类、多个方法、指定线程、指定耗时时间</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># trace -E 表示正则</span><br><span class="line">trace -E </span><br><span class="line"># 表示类是 NioEventLoop 或者 SingleThreadEventExecutor</span><br><span class="line">&#x27;io\.netty\.channel\.nio\.NioEventLoop|io\.netty\.util\.concurrent\.SingleThreadEventExecutor&#x27;  </span><br><span class="line"># 表示方法是 select processSelectedKeys runAllTasks</span><br><span class="line">&#x27;select|processSelectedKeys|runAllTasks&#x27; </span><br><span class="line"># @Thread arthas提供表示当前线程 #cost arthas提供，表示耗时</span><br><span class="line">&#x27;@Thread@currentThread().getName().contains(&quot;IO-HTTP-WORKER-IOPool&quot;)&amp;&amp;#cost&gt;500&#x27;</span><br></pre></td></tr></table></figure></li><li><p>获取代理对象的原始对象</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -w &#x27;#isProxy=:[ @org.springframework.aop.support.AopUtils@isAopProxy(#this)?1: #this instanceof java.lang.reflect.Proxy ? 0 :-1],#isJdkDynamicProxy =:[@org.springframework.aop.support.AopUtils@isJdkDynamicProxy(#this) ? true :false ],#cglibTarget =:[#hField =#this.getClass().getDeclaredField(&quot;CGLIB$CALLBACK_0&quot;),#hField.setAccessible(true),#dynamicAdvisedInterceptor=#hField.get(#this),#fieldAdvised=#dynamicAdvisedInterceptor.getClass().getDeclaredField(&quot;advised&quot;),#fieldAdvised.setAccessible(true),1==1? #fieldAdvised.get(#dynamicAdvisedInterceptor).getTargetSource().getTarget():null],#jdkTarget=:[ #hField=#this.getClass().getSuperclass().getDeclaredField(&quot;h&quot;),#hField.setAccessible(true),#aopProxy=#hField.get(#this),#advisedField=#aopProxy.getClass().getDeclaredField(&quot;advised&quot;),#advisedField.setAccessible(true),1==1?#advisedField.get(#aopProxy).getTargetSource().getTarget():null],#nonProxyResultFunc = :[#proxyResul=#isProxy(#this),#proxyResul== -1 ?#this :#proxyResul== 0? @java.lang.reflect.Proxy@getInvocationHandler(#this):#isJdkDynamicProxy(#this)? #isJdkDynamicProxy(#this) : #cglibTarget(#this)],#nonProxyTarget=#nonProxyResultFunc(target),#nonProxyTarget&#x27;  -x 1 -i 1002</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-Vmtool-使用"><a href="#6-Vmtool-使用" class="headerlink" title="6. Vmtool 使用"></a>6. Vmtool 使用</h3><blockquote><p><code>vmtool</code> 利用 Java 的 Instrumentation API 和 JVM TI（JVM Tool Interface）与 JVM 进行交互，可以绕过spring context 直接获取对象</p></blockquote><ul><li><p>常用子命令</p><ul><li><code>--action getInstances</code>：获取类的实例</li><li><code>--action forceGc</code>：强制执行垃圾回收</li><li><code>--action getClassLoader</code>：获取类加载器信息</li></ul></li><li><p>com.xxx.cache.CacheAspect 中的 boolean 变量 cacheEnabled 修改为false</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vmtool: Arthas 的一个命令，用于对 JVM 进行底层操作。</span><br><span class="line">-x 3: 设置执行次数限制为 3 次。</span><br><span class="line">--action getInstances: 指定操作为获取类的实例。</span><br><span class="line">--className com.xxx.cache.CacheAspect: 指定要操作的类名。</span><br><span class="line">--express: 后面跟着的是要执行的 OGNL 表达式</span><br><span class="line">ongl表达式:</span><br><span class="line">反射获取字段 #field=instances[0].getClass().getDeclaredField(&quot;cacheEnabled&quot;)</span><br><span class="line">设置为true #field.setAccessible(true)</span><br><span class="line">修改字段 #field.set(instances[0],false)</span><br><span class="line"></span><br><span class="line">vmtool -x 3 --action getInstances --className com.xxx.cache.CacheAspect --express &#x27;#field=instances[0].getClass().getDeclaredField(&quot;cacheEnabled&quot;),#field.setAccessible(true),#field.set(instances[0],false)&#x27; -c 3bd94634</span><br></pre></td></tr></table></figure></li><li><p>修改final变量</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmtool -x 4 --action getInstances --className com.wangji92.arthas.plugin.demo.controller.CommonController  --express &#x27;#field=instances[0].getClass().getDeclaredField(&quot;FINAL_VALUE&quot;),#modifiers=#field.getClass().getDeclaredField(&quot;modifiers&quot;),#modifiers.setAccessible(true),#modifiers.setInt(#field,#field.getModifiers() &amp; ~@java.lang.reflect.Modifier@FINAL),#field.setAccessible(true),#field.set(instances[0],&quot; 3333&quot;)&#x27; -c  18b4aac2</span><br></pre></td></tr></table></figure></li><li><p>执行某个方法</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vmtool -x 1 --action getInstances </span><br><span class="line">--className com.xx.SyncDataAuthController </span><br><span class="line">--express &#x27;instances[0].getDataCodePage(@com.xx.UtilJson@convertValue(&quot;&#123;\&quot;pageIndex\&quot;:0,\&quot;pageSize\&quot;:0&#125;&quot;, @com.xx.BaseQuery@class))&#x27;</span><br><span class="line">-c 49c2faae</span><br></pre></td></tr></table></figure></li><li><p>获取spring context</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmtool --action getInstances --className org.springframework.context.ConfigurableApplicationContext --express &#x27;instances[0].getEnvironment().getProperty(&quot;server.port&quot;)&#x27;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/alibaba/arthas/issues/71&quot;&gt;Arthas的一些特殊用法文档说明 · Issue #71 · alibaba&amp;#x2F;arthas&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/alibaba/arthas/issues/1424&quot;&gt;arthas 获取spring被代理的目标对象 · Issue #1424 · alibaba&amp;#x2F;arthas&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/alibaba/arthas/issues/537&quot;&gt;Arthas实践–jad&amp;#x2F;mc&amp;#x2F;redefine线上热更新一条龙 · Issue #537 · alibaba&amp;#x2F;arthas&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-获取当前HttpServletRequest&quot;&gt;&lt;a href=&quot;#1-获取当前HttpServletRequest&quot; class=&quot;headerlink&quot; title=&quot;1. 获取当前HttpServletRequest&quot;&gt;&lt;/a&gt;1. 获取当前HttpServletRequest&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;执行某个request方法&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;@org.springframework.web.context.request.RequestContextHolder@currentRequestAttributes().getRequest().xxx&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;获取全部的请求头&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;@org.springframework.web.context.request.RequestContextHolder@currentRequestAttributes().getRequest().getHeaderNames()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Arthas" scheme="https://braveliao.github.io/categories/Arthas/"/>
    
    
    <category term="Arthas" scheme="https://braveliao.github.io/tags/Arthas/"/>
    
    <category term="问题排查" scheme="https://braveliao.github.io/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>Tool</title>
    <link href="https://braveliao.github.io/2025/02/09/tool/tool/posts/undefined/"/>
    <id>https://braveliao.github.io/2025/02/09/tool/tool/posts/undefined/</id>
    <published>2025-02-09T06:51:22.000Z</published>
    <updated>2025-02-18T11:37:30.804Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-在线json格式化"><a href="#1-在线json格式化" class="headerlink" title="1. 在线json格式化"></a>1. 在线json格式化</h3><p><a href="https://www.json.cn/">https://www.json.cn/</a></p><h3 id="2-AI问答工具"><a href="#2-AI问答工具" class="headerlink" title="2. AI问答工具"></a>2. AI问答工具</h3><p><a href="https://chatgpt.com/">https://chatgpt.com/</a></p><h3 id="3-idea绘制uml"><a href="#3-idea绘制uml" class="headerlink" title="3. idea绘制uml"></a>3. idea绘制uml</h3><ul><li>安装PlantUML插件</li></ul><ol><li>打开 IntelliJ IDEA。</li><li>在顶部菜单栏选择 File -&gt; Settings。</li><li>在设置窗口中，选择 Plugins。</li><li>搜索 PlantUML，点击 Install 按钮进行安装。</li><li>安装完成后，重启 IntelliJ IDEA。</li></ol><ul><li>PlantUML代码参考</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">actor 运营 as User</span><br><span class="line">participant 管理系统 as ManagementSystem</span><br><span class="line">participant xx as API</span><br><span class="line"></span><br><span class="line">User -&gt; ManagementSystem : 创建会议并获取会议ID</span><br><span class="line">note right of User</span><br><span class="line">    会议ID从xx官网创建得到</span><br><span class="line">end note</span><br><span class="line">ManagementSystem -&gt; API : 调用API接口获取会议详情</span><br><span class="line">API -&gt; ManagementSystem : 返回会议详情</span><br><span class="line">ManagementSystem -&gt; ManagementSystem : 填充会议详情到系统</span><br><span class="line">ManagementSystem -&gt; User : 完成录入</span><br><span class="line">@enduml</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-在线json格式化&quot;&gt;&lt;a href=&quot;#1-在线json格式化&quot; class=&quot;headerlink&quot; title=&quot;1. 在线json格式化&quot;&gt;&lt;/a&gt;1. 在线json格式化&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.json.cn/&quot;&gt;https://www.json.cn/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-AI问答工具&quot;&gt;&lt;a href=&quot;#2-AI问答工具&quot; class=&quot;headerlink&quot; title=&quot;2. AI问答工具&quot;&gt;&lt;/a&gt;2. AI问答工具&lt;/h3&gt;</summary>
    
    
    
    <category term="Tool" scheme="https://braveliao.github.io/categories/Tool/"/>
    
    
    <category term="常用工具" scheme="https://braveliao.github.io/tags/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
