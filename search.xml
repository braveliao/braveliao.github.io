<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring Boot学习-手写ioc并理解核心原理</title>
    <url>/2025/02/09/springboot-xue-xi/spring-xi-lie-zhi-ioc-de-yuan-li-ji-shou-dong-shi-xian/posts/undefined/</url>
    <content><![CDATA[<h1 id="核心理解："><a href="#核心理解：" class="headerlink" title="核心理解："></a>核心理解：</h1><ol>
<li>ioc的名字理解：全称为Inversion of Controller</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在传统的编程模型中，对象的创建和依赖关系是由程序本身显式控制的。也就是说，程序员需要手动创建对象并将它们注入到其他对象中。这种方式被称为 控制（Control），程序员有完全的控制权来管理对象的生命周期和依赖关系。</span><br><span class="line"></span><br><span class="line">而 控制反转（IoC） 则是将这些控制权从程序中反转到框架或容器中。换句话说，IoC 允许框架（如 Spring）负责对象的创建和管理，而程序员则无需手动控制对象的生命周期和依赖关系。对象的创建和注入是由 IoC 容器来管理的。</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>核心功能：对Bean进行管理，包括创建、使用、销毁等；</li>
<li>ioc最核心的实现方式：依赖注入（DI）;</li>
</ol>
<h1 id="核心代码实现："><a href="#核心代码实现：" class="headerlink" title="核心代码实现："></a>核心代码实现：</h1><ol>
<li>创建一个简单的接口和实现类：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义服务接口</span><br><span class="line">public interface GreetingService &#123;</span><br><span class="line">    void greet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现 GreetingService</span><br><span class="line">public class GreetingServiceImpl implements GreetingService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void greet() &#123;</span><br><span class="line">        System.out.println(&quot;Hello, welcome to IoC container!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.创建一个简单的ioc容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">// 简单的 IoC 容器实现</span><br><span class="line">public class SimpleIoCContainer &#123;</span><br><span class="line">    private Map&lt;Class&lt;?&gt;, Object&gt; container = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    // 注册对象到容器</span><br><span class="line">    public void register(Class&lt;?&gt; clazz, Object object) &#123;</span><br><span class="line">        container.put(clazz, object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据类型获取对象</span><br><span class="line">    public &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        return clazz.cast(container.get(clazz));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>使用ioc容器</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">// 简单的 IoC 容器实现</span><br><span class="line">public class SimpleIoCContainer &#123;</span><br><span class="line">    private Map&lt;Class&lt;?&gt;, Object&gt; container = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    // 注册对象到容器</span><br><span class="line">    public void register(Class&lt;?&gt; clazz, Object object) &#123;</span><br><span class="line">        container.put(clazz, object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据类型获取对象</span><br><span class="line">    public &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        return clazz.cast(container.get(clazz));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Arthas</title>
    <url>/2025/02/09/arthas/arthas/posts/undefined/</url>
    <content><![CDATA[<ul>
<li><p><a href="https://github.com/alibaba/arthas/issues/71">Arthas的一些特殊用法文档说明 · Issue #71 · alibaba&#x2F;arthas</a></p>
</li>
<li><p><a href="https://github.com/alibaba/arthas/issues/1424">arthas 获取spring被代理的目标对象 · Issue #1424 · alibaba&#x2F;arthas</a></p>
</li>
<li><p><a href="https://github.com/alibaba/arthas/issues/537">Arthas实践–jad&#x2F;mc&#x2F;redefine线上热更新一条龙 · Issue #537 · alibaba&#x2F;arthas</a></p>
</li>
</ul>
<h3 id="1-获取当前HttpServletRequest"><a href="#1-获取当前HttpServletRequest" class="headerlink" title="1. 获取当前HttpServletRequest"></a>1. 获取当前HttpServletRequest</h3><ul>
<li><p>执行某个request方法</p>
<p>  <code>@org.springframework.web.context.request.RequestContextHolder@currentRequestAttributes().getRequest().xxx</code></p>
</li>
<li><p>获取全部的请求头</p>
<p>  <code>@org.springframework.web.context.request.RequestContextHolder@currentRequestAttributes().getRequest().getHeaderNames()</code></p>
</li>
</ul>
<h3 id="2-获取spring-context-并执行某些操作"><a href="#2-获取spring-context-并执行某些操作" class="headerlink" title="2. 获取spring context 并执行某些操作"></a>2. 获取spring context 并执行某些操作</h3><blockquote>
<p><strong>前置</strong> 使用tt记录请求，获取到上下文</p>
<p>tt -t org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter invokeHandlerMethod -n 3</p>
</blockquote>
<pre><code>tt -i 1000 -w &#39;target.getApplicationContext().getBean(&quot;jdbcTemplate&quot;)&#39;

tt -i 1000 -w &#39;target.getApplicationContext().getBean(&quot;jdbcTemplate&quot;).dataSource.ConnectionPool&#39;

tt -i 1000 -w &#39;target.getApplicationContext().getBean(&quot;jdbcTemplate&quot;).getTargetSource().target&#39;

tt -i 1000 -w &#39;target.getApplicationContext().getBean(&quot;jdbcTemplate&quot;).getTargetSource().target.cacheMap&#39;

tt -i 1000  -w &#39;target.getApplicationContext().getEnvironment().getProperty(&quot;spring.datasource.riskctrl.url&quot;)&#39;
</code></pre>
<h3 id="3-使用ognl"><a href="#3-使用ognl" class="headerlink" title="3. 使用ognl"></a>3. 使用<a href="https://commons.apache.org/dormant/commons-ognl/language-guide.html">ognl</a></h3><ul>
<li><p>对前置表达式值进行二次计算  #this 表示前置表达式的值 <strong><code>.()</code></strong> 表示自表达式，产生一个单一值</p>
<p>  <strong><code>listeners.size().(#this &gt; 100? 2\*#this : 20+#this)</code></strong></p>
</li>
<li><p>对前置表达式进行二次计算，产生一个数组</p>
<p>  <strong><code>params[0].&#123;#this == &quot;lei&quot; ?  &quot;yes&quot; : &quot;no&quot;&#125;</code></strong></p>
</li>
<li><p>对前置表达式(数组类型)进行二次计算，产生一个新的数组</p>
<p>  <strong><code>params.&#123;#this instanceof String ?  &quot;yes&quot; : &quot;no&quot;&#125;</code></strong></p>
</li>
<li><p>返回数组中第一个匹配的对象</p>
<p>  <strong><code>params.&#123;^#this instanceof Integer&#125;</code></strong></p>
</li>
<li><p>调用static方法 使用  <strong>@class@method(<strong><strong>args</strong></strong>)</strong></p>
<p>  <strong><code>@org.springframework.web.context.request.RequestContextHolder@currentRequestAttributes()</code></strong></p>
</li>
<li><p>获取静态字段 <strong>@class@field</strong></p>
</li>
</ul>
<h3 id="4-一些常用命令"><a href="#4-一些常用命令" class="headerlink" title="4. 一些常用命令"></a>4. 一些常用命令</h3><ul>
<li><p>获取classloader hash，如果是springBoot项目取 org.springframework.boot.loader.LaunchedURLClassLoader</p>
<p>  <strong><code>classloader -t</code></strong></p>
</li>
<li><p>容器安装 vim</p>
<p>  <strong><code>apt-get update &amp;&amp; apt-get install -y vim</code></strong></p>
</li>
<li><p>Ognl 获取spring context</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 49c2faae 表示classloader hash</span><br><span class="line"># cn.hutool.extra.spring.SpringUtil 表示能获取到spring容器的方法</span><br><span class="line">ognl -c 49c2faae &#x27;#beanName=&quot;eventDataAuthManage&quot;, #bean=@cn.hutool.extra.spring.SpringUtil@getBean(#beanName), @org.springframework.aop.support.AopUtils@getTargetClass(#bean).getName()&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Ognl lambda 表达式</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- 使用 =:[] 定义lambda即函数</span><br><span class="line">-- 使用 #getBean() 调用</span><br><span class="line">ognl -c 49c2faae &#x27;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">getBean =:[@cn.hutool.extra.spring.SpringUtil@getBean(#this)],</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">getBean(<span class="string">&quot;syncDataAuthController&quot;</span>).dataCodeList<span class="string">&#x27;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查找方法</p>
<p>  <strong><code>sm com.xx.class</code></strong></p>
</li>
<li><p>修改静态变量的值</p>
<p>  <strong><code>getstatic com.xyz.HelloWorld s &quot;#s=&#39;abc&#39;&quot;</code></strong></p>
</li>
<li><p>修改变量的值</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- 1. 使用 tt 记录方法调用</span><br><span class="line">tt -t com.example.UserService getUserById</span><br><span class="line">-- 2. 查看记录</span><br><span class="line">tt -l</span><br><span class="line">-- 3. 修改捕获的对象 target 代表当前被调用方法的对象实例（即 &quot;this&quot; 对象）</span><br><span class="line">tt -i 1000 -w &#x27;target.name=&quot;newName&quot;&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>过滤参数类型为class的方法</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- 过滤要点就是通过全类名@class拿到class对象，再getName()获取名称</span><br><span class="line">watch com.wangji92.arthas.plugin.demo.controller.StaticTest invokeClass &#x27;&#123;returnObj,throwExp&#125;&#x27;  -n 5  -x 3  </span><br><span class="line">&#x27;params[0].getName().equals(@com.wangji92.arthas.plug.demo.controller.User@class.getName())&#x27; -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找response404的堆栈</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stack -E javax.servlet.http.HttpServletResponse sendError|setStatus params[0]==404</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-特殊命令"><a href="#5-特殊命令" class="headerlink" title="5. 特殊命令"></a>5. 特殊命令</h3><ul>
<li><p>Trace 命令多个类、多个方法、指定线程、指定耗时时间</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># trace -E 表示正则</span><br><span class="line">trace -E </span><br><span class="line"># 表示类是 NioEventLoop 或者 SingleThreadEventExecutor</span><br><span class="line">&#x27;io\.netty\.channel\.nio\.NioEventLoop|io\.netty\.util\.concurrent\.SingleThreadEventExecutor&#x27;  </span><br><span class="line"># 表示方法是 select processSelectedKeys runAllTasks</span><br><span class="line">&#x27;select|processSelectedKeys|runAllTasks&#x27; </span><br><span class="line"># @Thread arthas提供表示当前线程 #cost arthas提供，表示耗时</span><br><span class="line">&#x27;@Thread@currentThread().getName().contains(&quot;IO-HTTP-WORKER-IOPool&quot;)&amp;&amp;#cost&gt;500&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取代理对象的原始对象</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tt -w &#x27;#isProxy=:[ @org.springframework.aop.support.AopUtils@isAopProxy(#this)?1: #this instanceof java.lang.reflect.Proxy ? 0 :-1],#isJdkDynamicProxy =:[@org.springframework.aop.support.AopUtils@isJdkDynamicProxy(#this) ? true :false ],#cglibTarget =:[#hField =#this.getClass().getDeclaredField(&quot;CGLIB$CALLBACK_0&quot;),#hField.setAccessible(true),#dynamicAdvisedInterceptor=#hField.get(#this),#fieldAdvised=#dynamicAdvisedInterceptor.getClass().getDeclaredField(&quot;advised&quot;),#fieldAdvised.setAccessible(true),1==1? #fieldAdvised.get(#dynamicAdvisedInterceptor).getTargetSource().getTarget():null],#jdkTarget=:[ #hField=#this.getClass().getSuperclass().getDeclaredField(&quot;h&quot;),#hField.setAccessible(true),#aopProxy=#hField.get(#this),#advisedField=#aopProxy.getClass().getDeclaredField(&quot;advised&quot;),#advisedField.setAccessible(true),1==1?#advisedField.get(#aopProxy).getTargetSource().getTarget():null],#nonProxyResultFunc = :[#proxyResul=#isProxy(#this),#proxyResul== -1 ?#this :#proxyResul== 0? @java.lang.reflect.Proxy@getInvocationHandler(#this):#isJdkDynamicProxy(#this)? #isJdkDynamicProxy(#this) : #cglibTarget(#this)],#nonProxyTarget=#nonProxyResultFunc(target),#nonProxyTarget&#x27;  -x 1 -i 1002</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-Vmtool-使用"><a href="#6-Vmtool-使用" class="headerlink" title="6. Vmtool 使用"></a>6. Vmtool 使用</h3><blockquote>
<p><code>vmtool</code> 利用 Java 的 Instrumentation API 和 JVM TI（JVM Tool Interface）与 JVM 进行交互，可以绕过spring context 直接获取对象</p>
</blockquote>
<ul>
<li><p>常用子命令</p>
<ul>
<li><code>--action getInstances</code>：获取类的实例</li>
<li><code>--action forceGc</code>：强制执行垃圾回收</li>
<li><code>--action getClassLoader</code>：获取类加载器信息</li>
</ul>
</li>
<li><p>com.xxx.cache.CacheAspect 中的 boolean 变量 cacheEnabled 修改为false</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vmtool: Arthas 的一个命令，用于对 JVM 进行底层操作。</span><br><span class="line">-x 3: 设置执行次数限制为 3 次。</span><br><span class="line">--action getInstances: 指定操作为获取类的实例。</span><br><span class="line">--className com.xxx.cache.CacheAspect: 指定要操作的类名。</span><br><span class="line">--express: 后面跟着的是要执行的 OGNL 表达式</span><br><span class="line">ongl表达式:</span><br><span class="line">反射获取字段 #field=instances[0].getClass().getDeclaredField(&quot;cacheEnabled&quot;)</span><br><span class="line">设置为true #field.setAccessible(true)</span><br><span class="line">修改字段 #field.set(instances[0],false)</span><br><span class="line"></span><br><span class="line">vmtool -x 3 --action getInstances --className com.xxx.cache.CacheAspect --express &#x27;#field=instances[0].getClass().getDeclaredField(&quot;cacheEnabled&quot;),#field.setAccessible(true),#field.set(instances[0],false)&#x27; -c 3bd94634</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改final变量</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vmtool -x 4 --action getInstances --className com.wangji92.arthas.plugin.demo.controller.CommonController  --express &#x27;#field=instances[0].getClass().getDeclaredField(&quot;FINAL_VALUE&quot;),#modifiers=#field.getClass().getDeclaredField(&quot;modifiers&quot;),#modifiers.setAccessible(true),#modifiers.setInt(#field,#field.getModifiers() &amp; ~@java.lang.reflect.Modifier@FINAL),#field.setAccessible(true),#field.set(instances[0],&quot; 3333&quot;)&#x27; -c  18b4aac2</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行某个方法</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vmtool -x 1 --action getInstances </span><br><span class="line">--className com.xx.SyncDataAuthController </span><br><span class="line">--express &#x27;instances[0].getDataCodePage(@com.xx.UtilJson@convertValue(&quot;&#123;\&quot;pageIndex\&quot;:0,\&quot;pageSize\&quot;:0&#125;&quot;, @com.xx.BaseQuery@class))&#x27;</span><br><span class="line">-c 49c2faae</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取spring context</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vmtool --action getInstances --className org.springframework.context.ConfigurableApplicationContext --express &#x27;instances[0].getEnvironment().getProperty(&quot;server.port&quot;)&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Arthas</category>
      </categories>
      <tags>
        <tag>Arthas</tag>
        <tag>问题排查</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2025/03/21/tool/p6-ti-sheng/posts/undefined/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Tool</title>
    <url>/2025/02/09/tool/tool/posts/undefined/</url>
    <content><![CDATA[<h3 id="1-在线工具"><a href="#1-在线工具" class="headerlink" title="1. 在线工具"></a>1. 在线工具</h3><ul>
<li>json工具 <a href="https://www.json.cn/">https://www.json.cn/</a></li>
<li>字符串压缩 <a href="https://www.txttool.com/t/?id=NDc3">https://www.txttool.com/t/?id=NDc3</a></li>
<li>uml在线绘制：<a href="https://www.mermaidchart.com/">https://www.mermaidchart.com/</a></li>
</ul>
<h3 id="2-AI问答工具"><a href="#2-AI问答工具" class="headerlink" title="2. AI问答工具"></a>2. AI问答工具</h3><p><a href="https://chatgpt.com/">https://chatgpt.com/</a></p>
<h3 id="3-idea绘制uml"><a href="#3-idea绘制uml" class="headerlink" title="3. idea绘制uml"></a>3. idea绘制uml</h3><ul>
<li>安装PlantUML插件</li>
</ul>
<ol>
<li>打开 IntelliJ IDEA。</li>
<li>在顶部菜单栏选择 File -&gt; Settings。</li>
<li>在设置窗口中，选择 Plugins。</li>
<li>搜索 PlantUML，点击 Install 按钮进行安装。</li>
<li>安装完成后，重启 IntelliJ IDEA。</li>
</ol>
<ul>
<li>PlantUML代码参考</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">actor 运营 as User</span><br><span class="line">participant 管理系统 as ManagementSystem</span><br><span class="line">participant xx as API</span><br><span class="line"></span><br><span class="line">User -&gt; ManagementSystem : 创建会议并获取会议ID</span><br><span class="line">note right of User</span><br><span class="line">    会议ID从xx官网创建得到</span><br><span class="line">end note</span><br><span class="line">ManagementSystem -&gt; API : 调用API接口获取会议详情</span><br><span class="line">API -&gt; ManagementSystem : 返回会议详情</span><br><span class="line">ManagementSystem -&gt; ManagementSystem : 填充会议详情到系统</span><br><span class="line">ManagementSystem -&gt; User : 完成录入</span><br><span class="line">@enduml</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-协作软件"><a href="#4-协作软件" class="headerlink" title="4. 协作软件"></a>4. 协作软件</h3><p><a href="https://worktile.com/">https://worktile.com/</a></p>
]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>常用工具</tag>
      </tags>
  </entry>
</search>
